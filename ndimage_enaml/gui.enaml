import logging
log = logging.getLogger(__name__)

from importlib import resources
from pathlib import Path

import numpy as np

from atom.api import set_default
from enaml.application import deferred_call
from enaml.core.api import Conditional, Looper
from enaml.icon import Icon, IconImage
from enaml.image import Image
from enaml.layout.api import align, hbox, InsertTab, RemoveItem, spacer, TabLayout, vbox
from enaml.stdlib.fields import FloatField, IntField
from enaml.stdlib.message_box import critical, information, question
from enaml.qt.QtCore import Qt
from enaml.widgets.api import (Action, ActionGroup, ButtonGroup, CheckBox,
                               Container, DockArea, DockItem, DualSlider,
                               Feature, FileDialogEx, Form, HGroup, Html,
                               Label, MainWindow, Menu, MenuBar, MPLCanvas,
                               ObjectCombo, PopupView, ProgressBar, PushButton,
                               Slider, VGroup, Window)


class NDImageCanvas(MPLCanvas):

    toolbar_visible = set_default(False)

    def set_focus(self, event=None):
        self.figure.canvas.setFocus(Qt.OtherFocusReason)


def bind_focus(items, cb):
    observe = ['toggled', 'selected', 'value', 'clicked']
    for item in items:
        for o in observe:
            if hasattr(item, o):
                item.observe(o, cb)
        if getattr(item, 'children', []):
            bind_focus(item.children, cb)


enamldef ChannelConfigPopup(PopupView):
    attr presenter
    attr display_apply = False

    anchor = (0.5, 0.0)
    parent_anchor = (0.5, 1.0)
    arrow_size = 20

    Container:
        layout_constraints => ():
            widgets = self.visible_widgets()
            cb = widgets[::2]
            slider = widgets[1::2]
            constraints = [vbox(*[hbox(c, s) for c, s in zip(cb, slider)])]
            constraints.append(align('left', *slider))
            constraints.append(align('left', *cb))
            return constraints

        Looper:
            iterable << presenter.current_artist.channel_config.items() \
                if presenter.current_artist is not None else {}

            CheckBox:
                text = loop_item[0]
                checked << loop_item[1].visible
                checked ::
                    presenter.set_channel_visible(loop_item[0], checked, display_apply)
            DualSlider:
                minimum = 0
                maximum = 100
                low_value << int(loop_item[1].min_value * 100)
                high_value << int(loop_item[1].max_value * 100)
                low_value ::
                    presenter.set_channel_min_value(loop_item[0], low_value / 100, display_apply)
                high_value ::
                    presenter.set_channel_max_value(loop_item[0], high_value / 100, display_apply)


enamldef DisplayConfig(HGroup): dc:

    attr presenter

    padding = 0
    align_widths = False
    share_layout = True
    trailing_spacer << spacer(0) if display_mode.selected == 'projection' else None

    Label: display_label:
        text = 'Display'

    PushButton: channels:
        text = 'Channels'
        clicked ::
            popup = ChannelConfigPopup(self, presenter=presenter)
            popup.show()

    Label: display_as_label:
        text = 'as'

    ObjectCombo: display_mode:
        items = ['projection', 'substack', 'slice']
        selected << presenter.current_artist.display_mode if (presenter and presenter.current_artist) else 'projection'
        selected ::
            presenter.set_display_mode(selected)

    Conditional:
        condition << display_mode.selected == 'substack'

        DualSlider: dz_slice:
            tick_interval = 1
            low_value << presenter.current_artist.z_slice_lb
            low_value ::
                presenter.set_z_slice_lb(low_value)
                if dz_constrain.checked:
                    presenter.set_z_slice_ub(low_value + dz_width.value)
            high_value << presenter.current_artist.z_slice_ub
            high_value ::
                presenter.set_z_slice_ub(high_value)
                if dz_constrain.checked:
                    presenter.set_z_slice_lb(high_value - dz_width.value)
            minimum << presenter.current_artist.z_slice_min
            maximum << presenter.current_artist.z_slice_max + 1
            tool_tip = 'Use up and down arrow keys when counting cells to scroll through z-steps'

        PushButton: dz_constrain:
            constraints = [width == 30]
            checkable = True
            text << 'ğŸ”’' if checked else 'ğŸ”“'

        IntField: dz_width:
            constraints = [width == 30]
            value << presenter.current_artist.z_slice_thickness
            value ::
                center = int(round((dz_slice.high_value + dz_slice.low_value) / 2))
                dz_slice.low_value = center - int(np.floor(value / 2))
                dz_slice.high_value = center + int(np.ceil(value / 2))

    Conditional:
        condition << display_mode.selected == 'slice'

        Slider: z_slice:
            tick_interval = 1
            value << presenter.current_artist.z_slice_lb
            value ::
                presenter.set_z_slice_lb(value)
                presenter.set_z_slice_ub(value + 1)
            minimum << presenter.current_artist.z_slice_min
            maximum << presenter.current_artist.z_slice_max - 1
            tool_tip = 'Use up and down arrow keys when counting cells to scroll through z-steps'

enamldef NDImageDockItem(DockItem): di:
    attr presenter

    closable = False
    Container: container:
        initialized ::
            deferred_call(bind_focus, container.children, canvas.set_focus)
            deferred_call(canvas.set_focus)
        DisplayConfig:
            presenter << di.presenter
        NDImageCanvas: canvas:
            figure << di.presenter.figure
